<html>
  <head>
  <Title>Make glb</Title>  
  <style>
 .area {
  width: 45em;
  padding: 15px;
  border: 1px solid #333;
  background: rgba(0,0,0,0.7);
}
#drop_zone {
  border: 2px dashed #bbb;
  -webkit-border-radius: 5px;
  border-radius: 5px;
  padding: 50px;
  text-align: center;
  font: 21pt bold arial;
  color: #bbb;
}

  </style>
  </head>
<body>
    <input type="file" id="files" name="files[]" multiple />
<div class="area">
    <div id="drop_zone">Drop files here</div>
</div>
<div id="download">
    <a href="#" id="downloadLink"></a>
</div>
<div>
    <ul id=list></ul></div>
<script>


  var files=[];
  var fileblobs=[];
  var gltf;
  var remainingfilestoprocess=0;
  var glbfilename;



  function handleDragOver(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; 
  }

  
  var dropZone = document.getElementById('drop_zone');
  dropZone.addEventListener('dragover', handleDragOver, false);
  dropZone.addEventListener('drop', handleFileSelect, false);


  function addDownloadButton() {
    var btn = document.createElement("button");
    btn.id="downloadBtn";
    btn.disabled=true;
    btn.onclick= startDownload;
    btn.appendChild(document.createTextNode("Processing..."));
    document.getElementById("download").appendChild(btn);
}

function startDownload(){
    document.getElementById("downloadLink").click();
}

  function handleFileSelect(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    document.getElementById('list').innerHTML="";
    addDownloadButton();
  var items = event.dataTransfer.items;
  remainingfilestoprocess=items.length;
  for (var i=0; i<items.length; i++) {    
    if (items[i].getAsEntry) {
    var entry = items[i].getAsEntry();
     } else if (items[i].webkitGetAsEntry) {
     var entry = items[i].webkitGetAsEntry();
    }
    if (entry) {
        traverseFileTree(entry);
    }
  }
  }

  function traverseFileTree(item, path) {
  path = path || "";
  if (item.isFile) {
    item.file(function(file) {
        files.push(file);
        var fileitem = '<li><strong>'+ escape(file.name)+ '</strong> ('+ file.type + ') - '+
                  file.size+ ' bytes, last modified: '+ file.lastModifiedDate +
                  '</li>';
        document.getElementById('list').innerHTML += fileitem;

        var extension = file.name.split('.').pop();
        if ( extension === "gltf")
          {
            glbfilename=file.name.substr(file.name.lastIndexOf('/')+1,file.name.lastIndexOf('.'));
          var reader = new FileReader();
          reader.readAsText(file);
          reader.onload = function(event) {
            gltf = JSON.parse(event.target.result);
            checkRemaining();
            };
        }
        else{
          var reader = new FileReader();
          reader.onload = (function(theFile) {
          return function(e) {
          fileblobs[theFile.name]=(e.target.result);
          checkRemaining();
          };
        })(file);
        reader.readAsArrayBuffer(file);
      }
    },function(error){
        console.log(error);
    });
  } else if (item.isDirectory) {
    var dirReader = item.createReader();
    dirReader.readEntries(function(entries) {
        remainingfilestoprocess+=entries.length;
        checkRemaining();
      for (var i=0; i<entries.length; i++) {
        traverseFileTree(entries[i], path + item.name + "/");
      }
    });
  }
}

function checkRemaining(){
    remainingfilestoprocess--;
    if(remainingfilestoprocess===0){
        fileSave();
    }
}

  function fileSave(){
  var Binary = {
          Magic: 0x46546C67
      };

      var bufferMap = new Map();
      var bufferOffset = 0;
      var outputBuffers = [];
      var bufferIndex = 0;
        for (; bufferIndex < gltf.buffers.length; bufferIndex++) {
        var buffer = gltf.buffers[bufferIndex];
        var data = dataFromUri(buffer);
        if (data !== undefined) {
            outputBuffers.push(data);
        }
        delete buffer['uri'];
        buffer['byteLength'] = data.byteLength;
        bufferMap.set(bufferIndex, bufferOffset);
        bufferOffset += alignedLength(data.byteLength);
    }
    for (var _i = 0, _a = gltf.bufferViews; _i < _a.length; _i++) {
        var bufferView = _a[_i];
        if(bufferView.byteOffset=== undefined){
            bufferView.byteOffset=0;
        }
        else{
        bufferView.byteOffset = bufferView.byteOffset + bufferMap.get(bufferView.buffer);
      }
        bufferView.buffer = 0;
    }
    if (gltf.images !== undefined) {
        for (var _b = 0, _c = gltf.images; _b < _c.length; _b++) {
            var image = _c[_b];
            var data = dataFromUri(image);
            if (data === undefined) {
                delete image['uri'];
                continue;
            }
            var bufferView = {
                buffer: 0,
                byteOffset: bufferOffset,
                byteLength: data.byteLength,
            };
            bufferMap.set(bufferIndex, bufferOffset);
            bufferIndex++;
            bufferOffset += alignedLength(data.byteLength);
            var bufferViewIndex = gltf.bufferViews.length;
            gltf.bufferViews.push(bufferView);
            outputBuffers.push(data);
            image['bufferView'] = bufferViewIndex;
            image['mimeType'] = getMimeType(image.uri);
            delete image['uri'];
        }
    }
    var binBufferSize = bufferOffset;
    gltf.buffers = [{
            byteLength: binBufferSize
        }];

    var enc = new TextEncoder();
    var jsonBuffer = enc.encode(JSON.stringify(gltf));
    var jsonAlignedLength = alignedLength(jsonBuffer.length);
    if (jsonAlignedLength !== jsonBuffer.length) {

        var padding = jsonAlignedLength- jsonBuffer.length;
    }
    var totalSize = 12 + // file header: magic + version + length
        8 + // json chunk header: json length + type
        jsonAlignedLength +
        8 + // bin chunk header: chunk length + type
        binBufferSize;
    var finalBuffer = new ArrayBuffer(totalSize);
    var dataView = new DataView(finalBuffer);
    var bufIndex = 0;
    dataView.setUint32(bufIndex, Binary.Magic, true);
    bufIndex += 4;
    dataView.setUint32(bufIndex, 2, true);
    bufIndex += 4;
    dataView.setUint32(bufIndex, totalSize, true);
    bufIndex += 4;
    // JSON
    dataView.setUint32(bufIndex, jsonAlignedLength, true);
    bufIndex += 4;
    dataView.setUint32(bufIndex, 0x4E4F534A, true);
    bufIndex += 4;

    for (var j=0;j<jsonBuffer.length;j++){
        dataView.setUint8(bufIndex, jsonBuffer[j]);
        bufIndex++;
    }
    if(padding!==undefined){
        for (var j=0;j<padding;j++){
            dataView.setUint8(bufIndex, 0x20);
        bufIndex++;
    }   
    }

    // BIN
    dataView.setUint32(bufIndex, binBufferSize, true);
    bufIndex += 4;
    dataView.setUint32(bufIndex, 0x004E4942, true);
    bufIndex += 4;
    for (var i = 0; i < outputBuffers.length; i++) {
      var bufoffset = bufIndex + bufferMap.get(i);    
      var buf = new Uint8Array(outputBuffers[i]);
      var thisbufindex=bufoffset;
      for (var j=0;j<buf.byteLength;j++){
        dataView.setUint8(thisbufindex, buf[j]);
        thisbufindex++;
    }
    }
    var a = document.getElementById("downloadLink");
    var file = new Blob([finalBuffer],{type: 'model/json-binary'})
    a.href = URL.createObjectURL(file);
    a.download = glbfilename+".glb";
    document.getElementById("downloadBtn").disabled=false;
    document.getElementById("downloadBtn").textContent="Download";

}


  function isBase64(uri) {
    return uri.length < 5 ? false : uri.substr(0, 5) === "data:";
}
function decodeBase64(uri) {
    //Todo
    return undefined;
}
function dataFromUri(buffer) {
    if (buffer.uri === undefined) {
        return undefined;
    }
    if (isBase64(buffer.uri)) {
        return decodeBase64(buffer.uri);
    }
    else {
      var filename=buffer.uri.substr(buffer.uri.lastIndexOf('/')+1);
      return fileblobs[filename];
    }
}
function alignedLength(value) {
    var alignValue = 4;
    if (value == 0) {
        return value;
    }
    var multiple = value % alignValue;
    if (multiple === 0) {
        return value;
    }
    return value + (alignValue - multiple);
}

function getMimeType(filename) {
    for (var mimeType in gltfMimeTypes) {
        for (var extensionIndex in gltfMimeTypes[mimeType]) {
            var extension = gltfMimeTypes[mimeType][extensionIndex];
            if (filename.toLowerCase().endsWith('.' + extension)) {
                return mimeType;
            }
        }
    }
    return 'application/octet-stream';
}

var gltfMimeTypes = {
    'image/png': ['png'],
    'image/jpeg': ['jpg', 'jpeg'],
    'text/plain': ['glsl', 'vert', 'vs', 'frag', 'fs', 'txt']
};

</script>
</body>
</html>
